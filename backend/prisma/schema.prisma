generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  user_id             String               @id @default(uuid()) @db.Uuid
  full_name           String               @db.VarChar(100)
  email               String               @unique @db.VarChar(100)
  password_hash       String?              @db.VarChar(255)
  phone               String?              @db.VarChar(20)
  avatar              String?              @db.VarChar(255)
  role                UserRole             @default(DRIVER)
  station_id          String?              @db.Uuid
  status              UserStatus           @default(ACTIVE)
  created_at          DateTime             @default(now())
  updated_at          DateTime             @updatedAt
  auth_provider       AuthProvider         @default(EMAIL)
  email_verified      Boolean              @default(false)
  google_id           String?              @unique @db.VarChar(100)
  last_login_at       DateTime?
  battery_transfers   BatteryTransferLog[]
  checked_in_bookings Booking[]            @relation("CheckedInByStaff")
  bookings            Booking[]
  payments            Payment[]
  station_ratings     StationRating[]
  assigned_tickets    SupportTicket[]      @relation("AssignedStaff")
  support_tickets     SupportTicket[]
  ticket_replies      TicketReply[]
  staff_transactions  Transaction[]        @relation("TransactionStaff")
  transactions        Transaction[]
  subscriptions       UserSubscription[]
  station             Station?             @relation(fields: [station_id], references: [station_id])
  vehicles            Vehicle[]
  wallet              Wallet?
  notifications       Notification[]
  staff_schedules     StaffSchedule[]

  @@map("users")
}

model Vehicle {
  vehicle_id    String        @id @default(uuid()) @db.Uuid
  user_id       String        @db.Uuid
  license_plate String        @unique @db.VarChar(20)
  vehicle_type  VehicleType
  make          String?       @db.VarChar(50)
  model         String?       @db.VarChar(50)
  year          Int?
  battery_model String        @db.VarChar(50)
  created_at    DateTime      @default(now())
  updated_at    DateTime      @updatedAt
  bookings      Booking[]
  transactions  Transaction[]
  user          User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("vehicles")
}

model Station {
  station_id             String               @id @default(uuid()) @db.Uuid
  name                   String               @db.VarChar(100)
  address                String               @db.VarChar(255)
  latitude               Decimal?             @db.Decimal(10, 6)
  longitude              Decimal?             @db.Decimal(10, 6)
  capacity               Int
  supported_models       Json
  operating_hours        String?              @db.VarChar(50)
  status                 StationStatus        @default(active)
  created_at             DateTime             @default(now())
  updated_at             DateTime             @updatedAt
  batteries              Battery[]
  battery_transfers_from BatteryTransferLog[] @relation("TransferFromStation")
  battery_transfers_to   BatteryTransferLog[] @relation("TransferToStation")
  bookings               Booking[]
  station_ratings        StationRating[]
  transactions           Transaction[]
  staff                  User[]
  staff_schedules        StaffSchedule[]

  @@map("stations")
}

model Battery {
  battery_id       String               @id @default(uuid()) @db.Uuid
  battery_code     String               @unique @db.VarChar(50)
  station_id       String               @db.Uuid
  model            String               @db.VarChar(50)
  capacity_kwh     Decimal?             @db.Decimal(6, 2)
  voltage          Decimal?             @db.Decimal(6, 2)
  current_charge   Int                  @default(100)
  health_percentage Decimal?            @db.Decimal(5, 2)
  cycle_count      Int?                 @default(0)
  status           BatteryStatus        @default(full)
  last_charged_at  DateTime?
  created_at       DateTime             @default(now())
  updated_at       DateTime             @updatedAt
  station          Station              @relation(fields: [station_id], references: [station_id])
  transfer_logs    BatteryTransferLog[]
  new_transactions Transaction[]        @relation("NewBattery")
  old_transactions Transaction[]        @relation("OldBattery")

  @@map("batteries")
}

model StaffSchedule {
  schedule_id String          @id @default(uuid()) @db.Uuid
  staff_id    String          @db.Uuid
  station_id  String?         @db.Uuid
  shift_date  DateTime        @db.Date
  shift_start DateTime
  shift_end   DateTime
  status      ScheduleStatus  @default(scheduled)
  notes       String?
  created_at  DateTime        @default(now())
  updated_at  DateTime        @updatedAt

  staff   User     @relation(fields: [staff_id], references: [user_id], onDelete: Cascade)
  station Station? @relation(fields: [station_id], references: [station_id])

  @@index([staff_id, shift_date])
  @@map("staff_schedules")
}

model Booking {
  booking_id             String        @id @default(uuid()) @db.Uuid
  booking_code           String        @unique @db.VarChar(20)
  user_id                String        @db.Uuid
  vehicle_id             String        @db.Uuid
  station_id             String        @db.Uuid
  battery_model          String        @db.VarChar(50)
  scheduled_at           DateTime
  status                 BookingStatus @default(pending)
  checked_in_at          DateTime?
  checked_in_by_staff_id String?       @db.Uuid
  pin_code               String?       @db.VarChar(6)
  pin_verified_at        DateTime?
  is_instant             Boolean       @default(false)
  notes                  String?
  created_at             DateTime      @default(now())
  checked_in_by_staff    User?         @relation("CheckedInByStaff", fields: [checked_in_by_staff_id], references: [user_id])
  station                Station       @relation(fields: [station_id], references: [station_id])
  user                   User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  vehicle                Vehicle       @relation(fields: [vehicle_id], references: [vehicle_id], onDelete: Cascade)
  transaction            Transaction?

  @@map("bookings")
}

model Transaction {
  transaction_id        String         @id @default(uuid()) @db.Uuid
  transaction_code      String         @unique @db.VarChar(30)
  booking_id            String         @unique @db.Uuid
  user_id               String         @db.Uuid
  vehicle_id            String         @db.Uuid
  station_id            String         @db.Uuid
  old_battery_id        String         @db.Uuid
  new_battery_id        String         @db.Uuid
  staff_id              String         @db.Uuid
  swap_at               DateTime       @default(now())
  swap_started_at       DateTime?
  swap_completed_at     DateTime?
  swap_duration_minutes Int?
  payment_status        PaymentStatus  @default(pending)
  amount                Decimal        @default(0) @db.Decimal(10, 2)
  notes                 String?
  created_at            DateTime       @default(now())
  payment               Payment?
  station_rating        StationRating?
  booking               Booking        @relation(fields: [booking_id], references: [booking_id], onDelete: Cascade)
  new_battery           Battery        @relation("NewBattery", fields: [new_battery_id], references: [battery_id])
  old_battery           Battery        @relation("OldBattery", fields: [old_battery_id], references: [battery_id])
  staff                 User           @relation("TransactionStaff", fields: [staff_id], references: [user_id])
  station               Station        @relation(fields: [station_id], references: [station_id])
  user                  User           @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  vehicle               Vehicle        @relation(fields: [vehicle_id], references: [vehicle_id], onDelete: Cascade)

  @@map("transactions")
}

model Payment {
  payment_id          String            @id @default(uuid()) @db.Uuid
  transaction_id      String?           @unique @db.Uuid
  subscription_id     String?           @db.Uuid
  topup_package_id    String?           @db.Uuid
  user_id             String            @db.Uuid
  amount              Decimal           @db.Decimal(10, 2)
  payment_method      PaymentMethod
  payment_status      PaymentStatus     @default(pending)
  payment_gateway_ref String?           @db.VarChar(100)
  paid_at             DateTime?
  payment_type        PaymentType       @default(OTHER)
  metadata            Json?
  created_at          DateTime          @default(now())
  subscription        UserSubscription? @relation(fields: [subscription_id], references: [subscription_id], onDelete: Cascade)
  topup_package       TopUpPackage?     @relation(fields: [topup_package_id], references: [package_id], onDelete: Cascade)
  transaction         Transaction?      @relation(fields: [transaction_id], references: [transaction_id], onDelete: Cascade)
  user                User              @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("payments")
}

model ServicePackage {
  package_id           String             @id @default(uuid()) @db.Uuid
  name                 String             @db.VarChar(100)
  description          String?
  price                Decimal            @db.Decimal(10, 2)
  battery_capacity_kwh Int
  swap_limit           Int?
  duration_days        Int
  battery_models       Json?
  benefits             Json?
  billing_cycle        PackageBillingCycle @default(monthly)
  metadata             Json?
  is_active            Boolean            @default(true)
  created_at           DateTime           @default(now())
  updated_at           DateTime           @updatedAt
  subscriptions        UserSubscription[]

  @@map("service_packages")
}

model UserSubscription {
  subscription_id     String             @id @default(uuid()) @db.Uuid
  user_id             String             @db.Uuid
  package_id          String             @db.Uuid
  start_date          DateTime
  end_date            DateTime
  remaining_swaps     Int?
  status              SubscriptionStatus @default(active)
  auto_renew          Boolean            @default(false)
  cancelled_at        DateTime?
  cancellation_reason String?
  metadata            Json?
  created_at          DateTime           @default(now())
  updated_at          DateTime           @updatedAt
  payments            Payment[]
  package             ServicePackage     @relation(fields: [package_id], references: [package_id])
  user                User               @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("user_subscriptions")
}

model SupportTicket {
  ticket_id            String         @id @default(uuid()) @db.Uuid
  ticket_number        String         @unique @db.VarChar(20)
  user_id              String         @db.Uuid
  category             TicketCategory
  subject              String         @db.VarChar(100)
  description          String
  priority             TicketPriority @default(medium)
  status               TicketStatus   @default(open)
  assigned_to_staff_id String?        @db.Uuid
  resolved_at          DateTime?
  created_at           DateTime       @default(now())
  updated_at           DateTime       @updatedAt
  assigned_to_staff    User?          @relation("AssignedStaff", fields: [assigned_to_staff_id], references: [user_id])
  user                 User           @relation(fields: [user_id], references: [user_id], onDelete: Cascade)
  replies              TicketReply[]

  @@map("support_tickets")
}

model TicketReply {
  reply_id   String        @id @default(uuid()) @db.Uuid
  ticket_id  String        @db.Uuid
  user_id    String        @db.Uuid
  message    String
  is_staff   Boolean       @default(false)
  created_at DateTime      @default(now())
  ticket     SupportTicket @relation(fields: [ticket_id], references: [ticket_id], onDelete: Cascade)
  user       User          @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("ticket_replies")
}

model StationRating {
  rating_id      String      @id @default(uuid()) @db.Uuid
  user_id        String      @db.Uuid
  station_id     String      @db.Uuid
  transaction_id String      @unique @db.Uuid
  rating         Int
  comment        String?
  created_at     DateTime    @default(now())
  updated_at     DateTime    @updatedAt
  station        Station     @relation(fields: [station_id], references: [station_id])
  transaction    Transaction @relation(fields: [transaction_id], references: [transaction_id], onDelete: Cascade)
  user           User        @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("station_ratings")
}

model BatteryTransferLog {
  transfer_id         String   @id @default(uuid()) @db.Uuid
  battery_id          String   @db.Uuid
  from_station_id     String   @db.Uuid
  to_station_id       String   @db.Uuid
  transfer_reason     String   @db.VarChar(100)
  transferred_by      String   @db.Uuid
  transferred_at      DateTime @default(now())
  notes               String?
  transfer_status     TransferStatus     @default(completed)
  battery             Battery  @relation(fields: [battery_id], references: [battery_id])
  from_station        Station  @relation("TransferFromStation", fields: [from_station_id], references: [station_id])
  to_station          Station  @relation("TransferToStation", fields: [to_station_id], references: [station_id])
  transferred_by_user User     @relation(fields: [transferred_by], references: [user_id])

  @@map("battery_transfer_logs")
}

model Wallet {
  wallet_id  String   @id @default(uuid()) @db.Uuid
  user_id    String   @unique @db.Uuid
  balance    Decimal  @default(0) @db.Decimal(10, 2)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  user       User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@map("wallets")
}

model BatteryPricing {
  pricing_id    String   @id @default(uuid()) @db.Uuid
  battery_model String   @db.VarChar(50)
  price         Decimal  @db.Decimal(10, 2)
  is_active     Boolean  @default(true)
  created_at    DateTime @default(now())
  updated_at    DateTime @updatedAt

  @@unique([battery_model])
  @@map("battery_pricings")
}

model TopUpPackage {
  package_id    String    @id @default(uuid()) @db.Uuid
  name          String    @db.VarChar(100)
  description   String?
  topup_amount  Decimal   @db.Decimal(10, 2)
  bonus_amount  Decimal   @db.Decimal(10, 2)
  actual_amount Decimal   @db.Decimal(10, 2)
  is_active     Boolean   @default(true)
  created_at    DateTime  @default(now())
  updated_at    DateTime  @updatedAt
  payments      Payment[]

  @@map("topup_packages")
}

model Notification {
  notification_id String   @id @default(uuid()) @db.Uuid
  user_id         String   @db.Uuid
  type            String   @db.VarChar(50)
  title           String   @db.VarChar(200)
  message         String   @db.Text
  is_read         Boolean  @default(false)
  data            Json?
  created_at      DateTime @default(now())
  user            User     @relation(fields: [user_id], references: [user_id], onDelete: Cascade)

  @@index([user_id, is_read])
  @@map("notifications")
}

enum UserRole {
  DRIVER
  STAFF
  ADMIN
}

enum UserStatus {
  ACTIVE
  INACTIVE
  BANNED
}

enum AuthProvider {
  EMAIL
  GOOGLE
}

enum VehicleType {
  car
  motorbike
}

enum StationStatus {
  active
  maintenance
  closed
}

enum BatteryStatus {
  full
  charging
  in_use
  maintenance
  damaged
}

enum BookingStatus {
  pending
  confirmed
  completed
  cancelled
}

enum PaymentStatus {
  pending
  completed
  failed
}

enum TransferStatus {
  pending
  in_transit
  completed
  cancelled
}

enum PaymentMethod {
  cash
  wallet
  vnpay
  momo
  credit_card
}

enum PaymentType {
  TOPUP
  SWAP
  SUBSCRIPTION
  REFUND
  OTHER
  PACKAGE_PURCHASE
  PACKAGE_REFUND
  PENALTY
}

enum ScheduleStatus {
  scheduled
  completed
  absent
  cancelled
}

enum SubscriptionStatus {
  active
  expired
  cancelled
}

enum PackageBillingCycle {
  monthly
  yearly
  custom
}

enum TicketCategory {
  battery_issue
  station_issue
  payment_issue
  service_complaint
  other
}

enum TicketPriority {
  low
  medium
  high
  urgent
}

enum TicketStatus {
  open
  in_progress
  resolved
  closed
}
